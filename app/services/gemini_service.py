import logging
import os
from typing import List, Dict, Any
from google import genai
from config import config
from app.models import Post

logger = logging.getLogger(__name__)

class GeminiService:
    def __init__(self):
        # Set the API key for the Google Gemini client
        os.environ['GEMINI_API_KEY'] = config.GEMINI_API_KEY
        self.client = genai.Client()
        self.model = "gemini-2.5-flash"
    
    async def close(self):
        """Close the client (no-op for Google Gemini client)"""
        pass
    
    def _build_prompt(self, topic_name: str, topic_description: str, past_posts: List[Post]) -> str:
        """Build the prompt for Gemini API"""
        
        base_prompt = """You are an educational content creator specializing in writing concise and informative educational snippets (maximum 200 characters) on various topics. Your goal is to help users learn more in an accessible and engaging way within a custom educational platform. These snippets are not for social media like Twitter, but designed for a learning environment.

The user will provide details about the topic, including its name and a brief description. Crucially, they will also share examples of past snippets they liked, disliked, or want to "dive deep" into.

Here's the input structure you'll receive:
topic:
name: [Topic Name]
description: [Brief description of the topic]
past_snippets:
- t1: [Snippet content 1] -> like (This snippet's style, tone, and content should be emulated.)
- t2: [Snippet content 2] -> dont like / not interested (Avoid this style, tone, or content.)
- t3: [Snippet content 3] -> dive deep (Create snippets that provide more detailed explanations or break down complex aspects of this specific sub-topic into digestible parts.)

Your task is to create 10 new, unique educational snippets about the given topic. Ensure these snippets:
1. **Align with user preferences:** Emulate the style and tone of 'liked' snippets and avoid elements from 'disliked' ones.
2. **Are engaging and informative:** Use emojis (if appropriate for a learning context), intriguing questions, and surprising facts or statistics to capture attention.
3. **Are concise and clear:** Adhere strictly to the 200-character limit per snippet. Avoid jargon where possible, or explain it simply and briefly.
4. **Address "dive deep" sub-topics:** For any 'dive deep' requests, provide more in-depth but still concise explanations, or simplify complex concepts.
5. **Maintain an educational tone:** Focus on delivering clear learning points without trying to be "viral" or overly informal.
6. **Avoid:** Overly academic language, rephrasing past liked snippets, sensationalism, misleading information, or elements specific to social media like hashtags.

Present each snippet as a numbered list item."""
        
        topic_section = f"""
topic:
name: {topic_name}
description: {topic_description}
past_snippets:"""
        
        if not past_posts:
            topic_section += "\n(No past snippets available - create diverse, engaging educational content)"
        else:
            for i, post in enumerate(past_posts, 1):
                status = "like" if post.like_status else "dont like" if post.dislike_status else "dive deep" if post.deep_dive else "neutral"
                topic_section += f"\n- t{i}: {post.post_content} -> {status}"
        
        return base_prompt + topic_section
    
    async def generate_posts(self, topic_name: str, topic_description: str, past_posts: List[Post]) -> List[str]:
        """Generate educational posts using Gemini API"""
        try:
            prompt = self._build_prompt(topic_name, topic_description, past_posts)
            
            logger.info(f"Generating posts for topic: {topic_name}")
            logger.info("=" * 80)
            logger.info("GEMINI API PROMPT:")
            logger.info("=" * 80)
            logger.info(prompt)
            logger.info("=" * 80)
            
            # Use the Google Gemini client
            response = self.client.models.generate_content(
                model=self.model,
                contents=prompt
            )
            
            if not response.text:
                logger.error("No content generated by Gemini API")
                return []
            
            content = response.text
            logger.info("=" * 80)
            logger.info("GEMINI API RESPONSE:")
            logger.info("=" * 80)
            logger.info(content)
            logger.info("=" * 80)
            
            posts = self._parse_posts_from_response(content)
            
            logger.info(f"Generated {len(posts)} posts for topic: {topic_name}")
            return posts
            
        except Exception as e:
            logger.error(f"Error calling Gemini API: {e}")
            return []
    
    def _parse_posts_from_response(self, content: str) -> List[str]:
        """Parse individual posts from Gemini's response"""
        posts = []
        lines = content.strip().split('\n')
        
        for line in lines:
            line = line.strip()
            # Look for numbered list items
            if line and (line[0].isdigit() or line.startswith(('•', '-', '*'))):
                # Remove numbering and list markers
                clean_line = line
                # Remove common numbering patterns
                import re
                clean_line = re.sub(r'^\d+\.?\s*', '', clean_line)
                clean_line = re.sub(r'^[•\-*]\s*', '', clean_line)
                clean_line = clean_line.strip()
                
                if clean_line and len(clean_line) <= 200:
                    posts.append(clean_line)
        
        # Fallback: if no numbered items found, try to split by sentences
        if not posts:
            sentences = content.split('.')
            for sentence in sentences:
                sentence = sentence.strip()
                if sentence and len(sentence) <= 200 and len(sentence) > 20:
                    posts.append(sentence)
        
        return posts[:config.POSTS_PER_TOPIC]  # Limit to configured number

gemini_service = GeminiService()